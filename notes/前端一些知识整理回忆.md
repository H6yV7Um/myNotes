[TOC]

# 前端知识整理回忆

## HTML


## CSS
 
### 垂直水平居中

水平居中:
- margin: 0 auto;
- text-align: center;
- position: relative; left: 50%; transform: translateX(-50%); // 不知道宽
- 定宽: position: relative; left: 50%; margin-left: -1/2 width px;
- .parent{ display: flex; justify-content: center; align-items: center; } 

垂直居中:
- 行内: line-height = height px;
- 块级: 定位 -> 设置top: 50%; margin-top: 1/2 height;
- dispaly:flex; align-items: center;

水平垂直居中:
- display: flex; .child{margin: auto;}
- dispaly: flex; justify-content: center; align-items: center; 
- positon: absolute; margin: auto; left: 0; right: 0; top: 0; bottom: 0;



### flex 布局

容器属性:
- display: flex;
- flex-wrap: no-wrap | wrap | wrap-reverse;
- flex-direction: row | row-reverse | column | column-reverse;
- flex-flow:  <flex-direction> || <flex-wrap>; /* flex-direction 和 flex-wrap 的简写形式*/
- justify-content: flex-start | flex-end | center | space-between | space-around; /* 在主轴上的对齐方式。 */
- align-items: flex-start | flex-end | center | baseline | stretch; /* 交叉轴上如何对齐 */

子项目属性:

- order:  <integer>; /* 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 */
- flex-grow:  <number>; /* default 0 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
 */
- flex-shrink: <number>; /* default 1 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 */
- flex-basis
- flex
- align-self

## javascript

### js中继承的实现



### 原型

#### Prototype chain

All javascript objects inherit properties and methods from their prototype. Objects created by the keyword new or with object literal, will inherit properties in the prototype chain.

当访问一个对象的属性的时候, 不仅会搜索该对象自身的属性还会顺着原型链查找原型链上属性. 

#### 原型意义

可以用来实现对象方法的继承共用.

#### 创建对象及原型继承的方法

>1. 构造函数

实例对象会通过原型链获取构造函数prototype上的属性.
Object.getPrototypeOf(jiafei); 可以得到jiafei的原型链(同 __proto__ )

```javascript

function Cat (name, age) {
    this.name = name;
    this.age = age;
}

Cat.prototype = {
    sayHello: function () {
        console.log('你好, 我是' + this.name);
    }
}

var jiafei = new Cat('加菲', 3);
var tom = new Cat('汤姆', 5);

```

>2. Object.crate(obj) 实现原型链的继承 

```javacript

var a = {
    name: 'a',
    sayHello: function () {
        console.log('我是' + this.name);
    }
};

var b = Object.create(a);

则 b.__proto__ = a;

```

>3. Class 关键字定义 并实例化的实例

实例化的子类通过原型链继承父类的原型.

```javascript

class People {
    constructor (name, age) {
        this.name = name;
        this.age = age;
    }
    sayHello () {
        console.log('我是' + this.name + '; 我今年' + this.age + '岁了.');
    }
}

class Student extends People {
    constructor (name, age, sex, job) {
        super(name, age);
        this.sex = sex;
        this.job = job;
    }
    work () {
        console.log('我是一个' + this.job + ', 我要开始工作了.');
    }
}

let xiaoMing = new Student('小明', 16, '男', '学生');

```


>4. 字面量创建的对象

```javascript

// 创建的对象会继承Object.prototype.
var o = {a: 1, b: 2};
// 创建的数组原型链指向Array.prototype.
var arr = [1, 2, 3];

```

### new 操作符细节

[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new)

- 1. 建立一个空对象
- 2. 该对象继承构造函数的原型
- 3. 执行构造函数, 并把该对象绑定为this, 进行构造函数的继承
- 4. 判断构造函数返回值的类型, 如果没有返回值或返回值是值类型, 则返回第二步创建的这个空对象, 否则返回原构造函数的返回结果.

**模拟new操作符**

```javascript

function _new(fn, args) {
    // 创建一个空对象, 继承fn的原型链.
    let obj = Object.create(fn.prototype);
    let res = fn.apply(obj, ...args);
    let type = typeof res;
    if (type === 'object' && type !== 'null') {
        return res;
    } else {
        return obj;
    }
}

```

### this 的情况

函数中的this与创建无关, 与调用有关.

- 全局作用域中的this为全局对象window或global.
- 函数中的this与调用有关, this不能在执行时被赋值. 函数执行时会通过内部的[[call]]方法调用 thisArg 和 argumentList 两个参数执行. 其中的thisArg与this有关.
    - 普通函数直接调用时 thisArg 为undefined.
    - 函数作为对象的属性调用, thisArg是该对象
    - 可以通过 apply, call, bind 来调用, thisArg是第一个参数
    - 构造函数实例化时 thisArg 指向新创建的对象. 
- thisArg 与 this的关系
    - If the function code is strict code, set the ThisBinding to thisArg.
    - Else if thisArg is null or undefined, set the ThisBinding to the global object.
    - Else if Type(thisArg) is not Object, set the ThisBinding to ToObject(thisArg). // thisArg如果是一个value类型, 则把该值转为对象, this指向该转换后的对象. 如 fn.call('abc'); 则 this = new String('abc');
    - Else set the ThisBinding to thisArg.

#### 使用中的this的情况

- 1. 全局上下文中 this = 全局对象
- 2. 严格模式下普通函数中的this = undefined.
- 3. 非严格模式下 普通函数中的this = 全局对象
- 4. 作为对象的方法调用 this = 该对象
- 5. 箭头函数中 this 为定义时的上下文对象. 不会改变
- 6. 对象的属性定义的 setter/getter 函数中的this为所设置的对象
- 7. call/apply/bind 可以改变this, 
    - 如果第一个参数是null/undefined 非严格模式下this是全局, 严格模式下this是null/undefined
    - 第一个参数是对象, this 指向该对象
    - 第一个参数是值类型, 将该值转为对象, 并绑定this为该转换后的对象.
- 8. 构造函数中的this实例化的时候指向实例对象. 若构造函数返回了一个对象类型, 则绑定this的对象丢失.
- 9. 原型链中的方法中的this指向调用该方法的对象.

### closure 闭包

函数在解析的时候会把当前的作用域与函数内部语句一起封装成一个封闭的环境, 这种现象称为闭包.

应用:

静态变量.
封闭作用域.

### instanceof typeof

typeof 判断数据类型
instanceof 判断是否是实例. 只要构造函数在对象的原型链上, 则都返回true

### 判断 数组

有3种方法

instanceof
Array.isArray()
Object.prototype.toString.call()

```javascript

var arr = [];
typeof arr // 'object' 判断不出来
arr instanceof Array // true
Array.isArray(arr) // true
Object.prototype.toString.call(arr) // 结果[object Array].  Object.prototype.toString 得到的结果是[object type], 其中type是所传对象的类型, 通过判断type可以得到类型. 直接调用Array.prototype.toString 得到一个字符串.不能判断

```

### js中的异步操作

- setTimeout, setInterval
- ajax
- IO 操作 fs.fileRead. 也可以是同步
- dom 事件
- promise


## ANGULAR

## VUE

## REACT

## OHTERS

### dns解析流程

1. 查看本地hosts文件, 有则返回, 无则继续.
2. 根据本地dns缓存解析, 有则返回, 无则继续.
3. 访问TCP/IP中配置的dns服务器. 若有则返回, 若无则访问服务器缓存的网址映射关系, 若有则返回. 若无则继续.
若无 dns服务器会有2种策略, 一种是转发到其他的dns服务器, 或者到转发到dns根服务器. 若是转发到其他dns服务器则继续相同的流程.
4. 访问13台根服务器. 根服务器会判断该根域名(.com)的解析服务器, 并返回该服务器的地址.
5. 访问相应的服务器, 如果服务器不能解析该域名, 则继续转发到下一级的dns服务器. 继续重复上面的动作. 




