# 为什么负数用补码表示

js中的数值根据IEEE-754标准按64位格式存储.  但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。

对于32位表示的整数. 前31位用于表示整数的值, 第32位是符号位, 1为正, 1为负.
如18 = 0000 0000 0000 0000 0000 0000 0001 0010;
 -18 = 1111 1111 1111 1111 1111 1111 1110 1110;

### js中的进制转换

十进制转其他

```javascript

//十进制转其他
var x=110;
w(x);
w(x.toString(8));
w(x.toString(32));
w(x.toString(16));

//其他转十进制
var x='110';
w(parseInt(x,2));
w(parseInt(x,8));
w(parseInt(x,16));

//其他转其他
//先用parseInt转成十进制再用toString转到目标进制 

```

### 负数的转换过程

- 将数值的绝对值转为二进制原码. 如 18 得到原码 0000 0000 0000 0000 0000 0000 0001 0010;
- 求得该二进制的反码 18的反码为 1111 1111 1111 1111 1111 1111 1110 1101
- 让该反码 + 1 结果为 1111 1111 1111 1111 1111 1111 1110 1110

在ECMAScript中，当对数值应用位操作符时，后台会发生如下转换过程：64位的数值被转换成32位数值，然后执行位操作，最后再将32位的结果转换回64位数值。这样，表面上看起来就好像是在操作32位数值。但这个转换过程也导致了一个严重的负效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理。如果对非数值进行位操作，会先使用Number()函数将该数值转换成一个数值（自动完成），然后再应用位操作，得到的结果是一个数值。


### 为什么要采用反码表示负数

反码只是一种表示方法, 不用反码也完全可以表示负数, 需要设置相应的解析规则即可. 那么用反码表示负数有什么优势呢?

其主要优势在于当做加法运算时可以使用同一套规则.

以下案例采用8位表示数字.

```
// 如采用原码来表示负数
则 16 + (-8)

  0001 0000
+ 1000 1000
  ---
  1001 1000

// 1001 1000 的结果是 -24 显然结果是错误的. 

// 如果用补码表示负数
  0001 0000
+ 1111 1000
  ---
 10000 1000

// 得到的结果是一个9位数, 对于8位机, 第9位会被舍弃, 则得到 0000 1000 = 8 即得到答案.

```

以上案例可以发现用补码表示负数加法一套运算规则可以同时适用正负数运算.

### 补码的本质

为什么负数要补码+1呢

```
// 如要得到-8. -8 = 0 - 8; 0 比 8 小, 减不了, 所以需要到高位上借一位.

 0000 0000
-0000 1000
 --------

// 从高位借位后 => 

 1 0000 0000
-  0000 1000
 -----
   1111 1000

// 由于被除数借了1位, 相当于 1 0000 0000 = 1111 1111 + 1, 以上步骤可以拆分为2步

 1 0000 0000
-  0000 1000
 -----

 // =>

 1111 1111
-0000 1000
 ----
 1111 0111  // 相当于取反得到补码

 // 再加1

 1111 0111
+0000 0001
 ----
 1111 1000 // 得到最后的结果

```







