<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>原型题目知识整理</title>
	<!-- 代码着色核心文件 -->
	<script type="text/javascript" src="js/syntaxhighlighter_3.0.83/src/shCore.js"></script> 
	<!-- 代码着色匹配代码类型的文件 -->
	<script type="text/javascript" src="js/syntaxhighlighter_3.0.83/scripts/shBrushJScript.js"></script>
	<!-- 代码高亮的css样式文件 -->
	<link type="text/css" rel="stylesheet" href="js/syntaxhighlighter_3.0.83/styles/shCoreEmacs.css"/>
	<!-- 当前页面的主题 修改theme后面的值就可以直接修改主题了-->
	<script type="text/theme" theme = "cyborg" id = "theme_strapdown"></script>

	<!-- 自己定义的css样式 -->
	<!-- <link rel="stylesheet"  type='text/css' href="css/base.css" /> -->
	
	<style type="text/css">

	</style>
</head>
<body>

<!-- 插入markDown -->

<xmp>

# 函数原型等题目整理

### 题目1.
题目: 下面程序输出的a,b,c,d值分别是什么
```
function fo(){
	var i = 0;
	return function(n){
		return n + i++;
	}
}


var f = fo(); 
var a = f(15); 
var b = fo()(15);  
var c = fo()(20); 
var d = f(20);

console.log(a);
console.log(b);
console.log(c);
console.log(d);
```
> 分析


1. var f = fo();  var m = fo()

	f == m 输出false; 因为2次定义每次fo都要执行,执行后返回的函数会开辟新的内存空间

 	执行fo函数,但是return的function不会执行, 其中的i值还没有改变.

2. var a = f(15); 
	此时a为15

3. var b = fo()(15);  

	由于闭包,这次计算i的值仍然取的0

	与 a = f(15)一样

	输出b: 15

4. var c = fo()(20); 

	由于闭包, i仍然取0

	c得到20

5. var d = f(20);

	d 得到21, 因为还调用的 f 函数, f函数内部有自己的作用域, 该作用域中的i值已经改变了


### 题目2  程序运行后，会弹出5次alert警告框。请问分别弹出的数值是什么？

```
var number = 2;
var obj = {
	number : 4,
	fn1 : (function(){
		this.number *= 2;
		number = number * 2;
		var number = 3;
		return function(){
			this.number *= 2;
			number *= 3;
			alert(number);
		}
	})(),
	db2 : function(){
		this.number *= 2;
	}
};


var fn1 = obj.fn1;
alert(number); 
fn1();   
obj.fn1(); 
alert(window.number);
alert(obj.number);
```
> 分析:

1. IIFE在定义的时候就会执行返回一个函数
	obj在定义的时候, obj.fn1 就会执行,并返回一个函数. 此后无论如何调用obj.fn1 其中 return以外的部分都不会再执行.

2. IIFE return出来的是一个函数, 不加括号调用的话不会自己执行

3. IIFE 自动执行后return出来一个函数, 即obj.fn1是一个函数, 当赋值给其他值的时候仍然是引用类型, 即都是同一个函数, 是全等的.
	如: 
---
	var fn = (function(){
		return function(){

		}
	}())
	var a = fn;
	var b = fn;
	console.log(a === b); // true
---


4. 函数中的this
	函数作为对象的方法调用时, this是这个对象
	如 obj.db2() 该方法中的this是obj
	函数在全局中执行又没有指定this的话this会指向window


### 3. 程序运行的结果是？

```
(function(m){
	var o = {
		a : m , 
		fn : function(n){
			console.log(this.a + n);
		}
	}
	return o.fn;
})(2)(3)
```

> 分析

IIFE 自执行后, 返回一个函数, 再次调用该函数是在window中执行, this是window
所以 this.a = undefined
最后的结果是 NaN

### 4. 程序执行结果
```
var length = 10;
function fn(){
    alert(this.length);
}
var obj = {
    length: 5,
    method: function(fn) {
        fn();
        arguments[0]();
    }
}
obj.method(fn);
```



</xmp>



<!-- js代码 -->
<script type="text/javascript">


	
</script>

<!-- //markdown格式化文件 -->
<script src="js/strapdown/strapdown_xiugai.js"></script>

<!-- SyntaxHighlighter 代码着色执行文件 -->
<script type="text/javascript">SyntaxHighlighter.all();</script>
<!-- 生成目录 -->
<script type="text/javascript" src="js/buildCatalog.js"></script>

</body>
</html>


<!-- 代码自动高亮模板 -->
<!-- <div class="daima">
	<script type="syntaxhighlighter" class="brush: js;">

	
	</script>
</div>
 -->